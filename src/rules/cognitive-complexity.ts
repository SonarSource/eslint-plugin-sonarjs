import { Rule } from "eslint";
import * as estree from "estree";
import { getParent, isIfStatement, isLogicalExpression } from "../utils/nodes";

const MESSAGE =
  "Refactor this function to reduce its Cognitive Complexity from {{complexity}} to the {{threshold}} allowed.";
const DEFAULT_THRESHOLD = 15;

type LoopStatement =
  | estree.ForStatement
  | estree.ForInStatement
  | estree.ForOfStatement
  | estree.DoWhileStatement
  | estree.WhileStatement;

type FunctionLike = estree.FunctionDeclaration | estree.FunctionExpression | estree.ArrowFunctionExpression;

type OptionalLocation = estree.SourceLocation | null | undefined;

const rule: Rule.RuleModule = {
  meta: {
    schema: [{ type: "integer", minimum: 0 }],
  },
  create(context: Rule.RuleContext) {
    const threshold: number = context.options[0] !== undefined ? context.options[0] : DEFAULT_THRESHOLD;

    let complexityIfNotNested = 0;
    let complexityIfNested = 0;

    /** Current nesting level (number of enclosing control flow statements and function likes) */
    let nesting = 0;

    /** Indicator if the current function like has a structural (generated by control flow statements) complexity */
    let topLevelHasStructuralComplexity = false;
    let topLevelOwnComplexity = 0;

    /** Nodes that should increase nesting level  */
    const nestingNodes: Set<estree.Node> = new Set();

    const logicalOperationsToIgnore: Set<estree.Node> = new Set();

    /** Stack of enclosing function likes */
    const enclosingFunctions: FunctionLike[] = [];

    const secondLevelFunctions: Set<{
      node: FunctionLike;
      complexityIfThisSecondaryIsTopLevel: number;
      complexityIfNested: number;
      loc: OptionalLocation;
    }> = new Set();

    return {
      FunctionDeclaration(node: estree.Node) {
        onEnterFunction(node as estree.FunctionDeclaration);
      },
      "FunctionDeclaration:exit"(node: estree.Node) {
        onLeaveFunction(node as estree.FunctionDeclaration);
      },
      FunctionExpression(node: estree.Node) {
        onEnterFunction(node as estree.FunctionExpression);
      },
      "FunctionExpression:exit"(node: estree.Node) {
        onLeaveFunction(node as estree.FunctionExpression);
      },
      ArrowFunctionExpression(node: estree.Node) {
        onEnterFunction(node as estree.ArrowFunctionExpression);
      },
      "ArrowFunctionExpression:exit"(node: estree.Node) {
        onLeaveFunction(node as estree.ArrowFunctionExpression);
      },

      "*"(node: estree.Node) {
        if (nestingNodes.has(node)) {
          nesting++;
        }
      },
      "*:exit"(node: estree.Node) {
        if (nestingNodes.has(node)) {
          nesting--;
          nestingNodes.delete(node);
        }
      },

      IfStatement(node: estree.Node) {
        visitIfStatement(node as estree.IfStatement);
      },
      ForStatement(node: estree.Node) {
        visitLoop(node as estree.ForStatement);
      },
      ForInStatement(node: estree.Node) {
        visitLoop(node as estree.ForInStatement);
      },
      ForOfStatement(node: estree.Node) {
        visitLoop(node as estree.ForOfStatement);
      },
      DoWhileStatement(node: estree.Node) {
        visitLoop(node as estree.DoWhileStatement);
      },
      WhileStatement(node: estree.Node) {
        visitLoop(node as estree.WhileStatement);
      },
      SwitchStatement(node: estree.Node) {
        visitSwitchStatement(node as estree.SwitchStatement);
      },
      ContinueStatement(node: estree.Node) {
        visitContinueOrBreakStatement(node as estree.ContinueStatement);
      },
      BreakStatement(node: estree.Node) {
        visitContinueOrBreakStatement(node as estree.BreakStatement);
      },
      CatchClause(node: estree.Node) {
        visitCatchClause(node as estree.CatchClause);
      },
      LogicalExpression(node: estree.Node) {
        visitLogicalExpression(node as estree.LogicalExpression);
      },
      ConditionalExpression(node: estree.Node) {
        visitConditionalExpression(node as estree.ConditionalExpression);
      },
    };

    function onEnterFunction(node: FunctionLike) {
      if (enclosingFunctions.length === 0) {
        // top level function
        topLevelHasStructuralComplexity = false;
        topLevelOwnComplexity = 0;
        secondLevelFunctions.clear();
      } else if (enclosingFunctions.length === 1) {
        // second level function
        complexityIfNotNested = 0;
        complexityIfNested = 0;
      } else {
        nesting++;
        nestingNodes.add(node);
      }
      enclosingFunctions.push(node);
    }

    function onLeaveFunction(node: FunctionLike) {
      enclosingFunctions.pop();
      if (enclosingFunctions.length === 0) {
        // top level function
        if (topLevelHasStructuralComplexity) {
          let totalComplexity = topLevelOwnComplexity;
          secondLevelFunctions.forEach(second => {
            totalComplexity += second.complexityIfNested;
          });
          checkFunction(node, totalComplexity, getLocationToReport(node));
        } else {
          checkFunction(node, topLevelOwnComplexity, getLocationToReport(node));
          secondLevelFunctions.forEach(second => {
            checkFunction(second.node, second.complexityIfThisSecondaryIsTopLevel, second.loc);
          });
        }
      } else if (enclosingFunctions.length === 1) {
        // second level function
        secondLevelFunctions.add({
          node,
          complexityIfNested,
          complexityIfThisSecondaryIsTopLevel: complexityIfNotNested,
          loc: getLocationToReport(node),
        });
      } else {
        // do nothing
      }
    }

    function visitIfStatement(ifStatement: estree.IfStatement) {
      const parent = getParent(context);
      // if the current `if` statement is `else if`, do not count it in structural complexity
      if (isIfStatement(parent) && parent.alternate === ifStatement) {
        addComplexity();
      } else {
        addStructuralComplexity();
      }

      // always increase nesting level inside `then` statement
      nestingNodes.add(ifStatement.consequent);

      // if `else` branch is not `else if` then
      // - increase nesting level inside `else` statement
      // - add +1 complexity
      if (ifStatement.alternate && !isIfStatement(ifStatement.alternate)) {
        nestingNodes.add(ifStatement.alternate);
        addComplexity();
      }
    }

    function visitLoop(loop: LoopStatement) {
      addStructuralComplexity();
      nestingNodes.add(loop.body);
    }

    function visitSwitchStatement(switchStatement: estree.SwitchStatement) {
      addStructuralComplexity();
      for (const switchCase of switchStatement.cases) {
        nestingNodes.add(switchCase);
      }
    }

    function visitContinueOrBreakStatement(statement: estree.ContinueStatement | estree.BreakStatement) {
      if (statement.label) {
        addComplexity();
      }
    }

    function visitCatchClause(catchClause: estree.CatchClause) {
      addStructuralComplexity();
      nestingNodes.add(catchClause.body);
    }

    function visitConditionalExpression(conditionalExpression: estree.ConditionalExpression) {
      addStructuralComplexity();
      nestingNodes.add(conditionalExpression.consequent);
      nestingNodes.add(conditionalExpression.alternate);
    }

    function visitLogicalExpression(logicalExpression: estree.LogicalExpression) {
      if (!logicalOperationsToIgnore.has(logicalExpression)) {
        const flattenedLogicalExpressions = flattenLogicalExpression(logicalExpression);

        let previous: estree.LogicalExpression | undefined;
        for (const current of flattenedLogicalExpressions) {
          if (!previous || previous.operator !== current.operator) {
            addComplexity();
          }
          previous = current;
        }
      }
    }

    function flattenLogicalExpression(node: estree.Node): estree.LogicalExpression[] {
      if (isLogicalExpression(node)) {
        logicalOperationsToIgnore.add(node);
        return [...flattenLogicalExpression(node.left), node, ...flattenLogicalExpression(node.right)];
      }
      return [];
    }

    function addStructuralComplexity() {
      const added = nesting + 1;
      if (enclosingFunctions.length === 1) {
        // top level function
        topLevelHasStructuralComplexity = true;
        topLevelOwnComplexity += added;
      } else {
        complexityIfNested += added + 1;
        complexityIfNotNested += added;
      }
    }

    function addComplexity() {
      if (enclosingFunctions.length === 1) {
        // top level function
        topLevelOwnComplexity++;
      } else {
        // second+ level function
        complexityIfNested++;
        complexityIfNotNested++;
      }
    }

    function checkFunction(node: FunctionLike, complexity: number, loc: OptionalLocation) {
      if (complexity > threshold) {
        const location = loc ? { loc } : { node };
        context.report({
          message: MESSAGE,
          data: { complexity: String(complexity), threshold: String(threshold) },
          ...location,
        });
      }
    }

    /**
     * Returns
     * - function name token for function declarations, methods and accessors
     * - "function" keyword for function expressions
     * - "=>" for arrow functions
     */
    function getLocationToReport(functionLike: FunctionLike): OptionalLocation {
      switch (functionLike.type) {
        case "FunctionDeclaration":
          // `FunctionDeclaration.id` can be null when it is `export default function` (despite of the @types/estree definition)
          if (functionLike.id) {
            return functionLike.id.loc;
          } else {
            const token = context.getSourceCode().getFirstToken(functionLike);
            return token && token.loc;
          }
        case "FunctionExpression":
          const parent = getParent(context);
          if (parent && parent.type === "MethodDefinition") {
            return parent.key.loc;
          } else {
            const token = context.getSourceCode().getFirstToken(functionLike);
            return token && token.loc;
          }
        case "ArrowFunctionExpression":
          const token = context.getSourceCode().getTokenBefore(functionLike.body);
          return token && token.loc;
      }
    }
  },
};

export = rule;
